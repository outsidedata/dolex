#!/usr/bin/env tsx
/**
 * Build script — bundles render/*.render.ts files into self-contained IIFE strings.
 *
 * Each *.render.ts exports `renderChart(container, spec)`. This script uses esbuild
 * to bundle each one (inlining shared.ts, theme/colors.ts, etc.) into an IIFE that
 * exposes `renderChart` as a global variable.
 *
 * Output: src/renderers/html/_generated/bundles.ts
 *
 * Usage:
 *   npx tsx scripts/build-render-bundles.ts
 *   npx tsx scripts/build-render-bundles.ts --watch
 */

import * as esbuild from 'esbuild';
import { readdirSync, writeFileSync } from 'node:fs';
import { join, basename } from 'node:path';

const RENDER_DIR = join(import.meta.dirname, '..', 'src', 'renderers', 'html', 'render');
const OUTPUT_FILE = join(import.meta.dirname, '..', 'src', 'renderers', 'html', '_generated', 'bundles.ts');

/** Convert kebab-case filename to camelCase bundle name: bar.render.ts → barBundle */
function toBundleName(filename: string): string {
  const base = filename.replace('.render.ts', '');
  const camel = base.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
  return camel + 'Bundle';
}

async function buildAll() {
  // Find all render files
  const files = readdirSync(RENDER_DIR)
    .filter(f => f.endsWith('.render.ts'))
    .sort();

  if (files.length === 0) {
    console.error('No *.render.ts files found in', RENDER_DIR);
    process.exit(1);
  }

  console.log(`Bundling ${files.length} render files...`);

  const exports: string[] = [];

  for (const file of files) {
    const entryPoint = join(RENDER_DIR, file);
    const bundleName = toBundleName(file);

    const result = await esbuild.build({
      entryPoints: [entryPoint],
      bundle: true,
      write: false,
      format: 'iife',
      globalName: '__dolex',
      target: 'es2020',
      platform: 'browser',
      // Minify whitespace but keep names readable for debugging
      minifyWhitespace: true,
      minifySyntax: false,
      minifyIdentifiers: false,
      // Don't try to resolve 'd3' or 'topojson' — they're CDN globals
      external: [],
      // Resolve .js imports to .ts files (ESM convention)
      resolveExtensions: ['.ts', '.tsx', '.js', '.jsx', '.json'],
    });

    if (result.errors.length > 0) {
      console.error(`Errors bundling ${file}:`, result.errors);
      process.exit(1);
    }

    let code = new TextDecoder().decode(result.outputFiles[0].contents);

    // Expose renderChart as a global (the IIFE assigns to __dolex)
    code += '\nvar renderChart = __dolex.renderChart;';

    // Use JSON.stringify for safe escaping of the bundle string
    const escaped = JSON.stringify(code);
    exports.push(`export const ${bundleName} = ${escaped};`);

    console.log(`  ✓ ${file} → ${bundleName} (${code.length} bytes)`);
  }

  // Write the generated bundles file
  const output = [
    '// AUTO-GENERATED by scripts/build-render-bundles.ts — DO NOT EDIT',
    '',
    ...exports,
    '',
  ].join('\n');

  writeFileSync(OUTPUT_FILE, output, 'utf-8');
  console.log(`\nWrote ${OUTPUT_FILE} (${files.length} bundles)`);
}

// Watch mode support
const isWatch = process.argv.includes('--watch');

if (isWatch) {
  console.log('Watch mode — rebuilding on changes...');
  const chokidar = await import('chokidar' as string).catch(() => null);
  if (!chokidar) {
    console.error('Watch mode requires chokidar. Install with: npm i -D chokidar');
    console.log('Running single build instead...');
    await buildAll();
  } else {
    await buildAll();
    const watcher = chokidar.watch([
      join(RENDER_DIR, '*.render.ts'),
      join(import.meta.dirname, '..', 'src', 'renderers', 'd3', 'shared.ts'),
      join(import.meta.dirname, '..', 'src', 'theme', 'colors.ts'),
    ]);
    watcher.on('change', async (path: string) => {
      console.log(`\nChanged: ${basename(path)}`);
      await buildAll();
    });
  }
} else {
  await buildAll();
}
